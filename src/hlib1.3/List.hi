interface List where {
infix  5 \\;
elemIndex :: (Prelude.Eq a) => a -> [a] -> Prelude.Maybe Prelude.Int   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
elemIndices :: (Prelude.Eq a) => a -> [a] -> [Prelude.Int]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
find :: (a -> Prelude.Bool) -> [a] -> Prelude.Maybe a   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
findIndex :: (a -> Prelude.Bool) -> [a] -> Prelude.Maybe Prelude.Int   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
findIndices :: (a -> Prelude.Bool) -> [a] -> [Prelude.Int]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
nub :: (Prelude.Eq a) => [a] -> [a]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
nubBy :: (a -> a -> Prelude.Bool) -> [a] -> [a]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
delete :: (Prelude.Eq a) => a -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
deleteBy :: (a -> a -> Prelude.Bool) -> a -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
(\\) :: (Prelude.Eq a) => [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1&2,F" ST #-};
deleteFirstsBy :: (a -> a -> Prelude.Bool) -> [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
union :: (Prelude.Eq a) => [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "T,F" ST #-};
unionBy :: (a -> a -> Prelude.Bool) -> [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "T,F" ST #-};
intersect :: (Prelude.Eq a) => [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1,F" ST #-};
intersectBy :: (a -> a -> Prelude.Bool) -> [a] -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1,F" ST #-};
intersperse :: a -> [a] -> [a]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
transpose :: [[a]] -> [[a]]   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
partition :: (a -> Prelude.Bool) -> [a] -> ([a], [a])   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
group :: (Prelude.Eq a) => [a] -> [[a]]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
groupBy :: (a -> a -> Prelude.Bool) -> [a] -> [[a]]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
inits :: [a] -> [[a]]   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
tails :: [a] -> [[a]]   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
isPrefixOf :: (Prelude.Eq a) => [a] -> [a] -> Prelude.Bool   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1,F" ST #-};
isSuffixOf :: (Prelude.Eq a) => [a] -> [a] -> Prelude.Bool   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1,F" ST #-};
mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
mapAccumR :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
sort :: (Prelude.Ord a) => [a] -> [a]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
sortBy :: (a -> a -> Prelude.Ordering) -> [a] -> [a]   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
insertBy :: (a -> a -> Prelude.Ordering) -> a -> [a] -> [a]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
maximumBy :: (a -> a -> a) -> [a] -> a   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
minimumBy :: (a -> a -> a) -> [a] -> a   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
genericLength :: (Prelude.Integral b) => [a] -> b   {-# ARITY _ = 2 #-}{-# STRICTNESS _ = "1,F" ST #-};
genericTake :: (Prelude.Integral a) => a -> [b] -> [b]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
genericDrop :: (Prelude.Integral a) => a -> [b] -> [b]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "2,F" ST #-};
genericSplitAt :: (Prelude.Integral a) => a -> [b] -> ([b], [b])   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "T,F" ST #-};
genericIndex :: (Prelude.Integral b) => [a] -> b -> a   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "1,F" ST #-};
genericReplicate :: (Prelude.Integral a) => a -> b -> [b]   {-# ARITY _ = 3 #-}{-# STRICTNESS _ = "T,F" ST #-};
zip4 :: [a] -> [b] -> [c] -> [d] -> [(a, b, c, d)]   {-# ARITY _ = 4 #-}{-# STRICTNESS _ = "0,F" ST #-};
zip5 :: [a] -> [b] -> [c] -> [d] -> [e] -> [(a, b, c, d, e)]   {-# ARITY _ = 5 #-}{-# STRICTNESS _ = "0,F" ST #-};
zip6 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [(a, b, c, d, e, f)]   {-# ARITY _ = 6 #-}{-# STRICTNESS _ = "0,F" ST #-};
zip7 :: [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [(a, b, c, d, e, f, g)]   {-# ARITY _ = 7 #-}{-# STRICTNESS _ = "0,F" ST #-};
zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]   {-# ARITY _ = 5 #-}{-# STRICTNESS _ = "1,F" ST #-};
zipWith5 :: (a -> b -> c -> d -> e -> f) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f]   {-# ARITY _ = 6 #-}{-# STRICTNESS _ = "1,F" ST #-};
zipWith6 :: (a -> b -> c -> d -> e -> f -> g) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g]   {-# ARITY _ = 7 #-}{-# STRICTNESS _ = "1,F" ST #-};
zipWith7 :: (a -> b -> c -> d -> e -> f -> g -> h) -> [a] -> [b] -> [c] -> [d] -> [e] -> [f] -> [g] -> [h]   {-# ARITY _ = 8 #-}{-# STRICTNESS _ = "1,F" ST #-};
unzip4 :: [(a, b, c, d)] -> ([a], [b], [c], [d])   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
unzip5 :: [(a, b, c, d, e)] -> ([a], [b], [c], [d], [e])   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
unzip6 :: [(a, b, c, d, e, f)] -> ([a], [b], [c], [d], [e], [f])   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-};
unzip7 :: [(a, b, c, d, e, f, g)] -> ([a], [b], [c], [d], [e], [f], [g])   {-# ARITY _ = 1 #-}{-# STRICTNESS _ = "0,F" ST #-}
}
